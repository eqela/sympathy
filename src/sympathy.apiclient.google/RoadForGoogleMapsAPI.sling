
/*
 * This file is part of Eqela Sympathy
 * Copyright (c) 2020-2022 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import jk.log
import jk.url
import jk.json
import jk.webclient
import sympathy.geo

class:

func forAPIKey(key as string) static as this
{
	var v = new this()
	v.apiKey = key
	return v
}

prop ctx as LoggingContext
prop apiKey as string
prop client as WebClient

func queryNearestRoads(points as vector<DynamicMap>) async as vector<SnappedPoint>
{
	if not points:
		Error.throw("noPointsSupplied", null)
	if not client:
		client = WebClient.instance()
	var sb = new StringBuilder()
	var first = true
	foreach point as DynamicMap in points {
		if not first:
			sb.appendString("|")
		sb.appendString(point.getString("latitude"))
		sb.appendString(",")
		sb.appendString(point.getString("longitude"))
		if first:
			first = false
	}
	var url = "https://roads.googleapis.com/v1"
	var response = await client.executeQuery(ctx, "GET", url .. "/nearestRoads?key=" .. URLEncoder.encode(apiKey) .. "&points=" .. URLEncoder.encode(sb.toString()), null, null)
	var data = JSONParser.parseBuffer(response.body) as DynamicMap
	if not data:
		Error.throw("invalidServerResponse", url)
	var snappedPoints = data.getDynamicVector("snappedPoints")
	if not snappedPoints || snappedPoints.getSize() < 0:
		Error.throw("noSnappedPointsFound", url)
	var sp = new vector<SnappedPoint>
	foreach point as DynamicMap in snappedPoints.toVector() {
		var p = SnappedPoint.forData(point)
		if not p:
			continue
		sp += p
	}
	return sp
}

func querySnapToRoads(point1 as GeoLocation, point2 as GeoLocation, interpolate as bool = false) async as vector<SnappedPoint>
{
	var v = new vector<GeoLocation>
	v += point1
	v += point2
	return await querySnapToRoadsVector(v, interpolate)
}

func querySnapToRoadsVector(points as vector<GeoLocation>, interpolate as bool = false) async as vector<SnappedPoint>
{
	if not points:
		Error.throw("noPointsSupplied", null)
	if not client:
		client = WebClient.instance()
	var url = "https://roads.googleapis.com/v1/snapToRoads"
	var sb = new StringBuilder()
	sb.appendString(url)
	sb.appendString("?key=")
	sb.appendString(URLEncoder.encode(apiKey))
	sb.appendString("&path=")
	var sb2 = new StringBuilder()
	var first = true
	foreach point in points {
		if not first {
			sb2.appendString("|")
		}
		else {
			first = false
		}
		sb2.appendDouble(point.latitude)
		sb2.appendString(",")
		sb2.appendDouble(point.longitude)
	}
	sb.appendString(URLEncoder.encode(sb2.toString()))
	if interpolate:
		sb.appendString("&interpolate=true")
	var response = await client.executeQuery(ctx, "GET", sb.toString(), null, null)
	var data = JSONParser.parseBuffer(response.body) as DynamicMap
	if not data:
		Error.forCode("invalidServerResponse", url)
	var snappedPoints = data.getDynamicVector("snappedPoints")
	if not snappedPoints || snappedPoints.getSize() < 0:
		Error.throw("noSnappedPointsFound", url)
	var sp = new vector<SnappedPoint>
	foreach point as DynamicMap in snappedPoints.toVector() {
		var p = SnappedPoint.forData(point)
		if not p:
			continue
		sp += p
	}
	return sp
}
