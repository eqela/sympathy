
/*
 * This file is part of Eqela Sympathy
 * Copyright (c) 2020-2022 J42 Pte Ltd
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import jk.console
import jk.log
import jk.json
import jk.env
import jk.template
import jk.fs
import sympathy.config
import sympathy.webserver

class is WebServerRpcRouter:

var smsApp as SympathySMSProviderForSMSApp
var mailProvider = createMailProvider()
var smsProvider = createSMSProvider()
var notificationProvider = createNotificationProvider()
var defaultLanguage = ServerConfig.accept("DEFAULT_LANGUAGE")
var defaultSenderAddress = ServerConfig.accept("DEFAULT_SENDER_ADDRESS")
var defaultSenderName = ServerConfig.accept("DEFAULT_SENDER_NAME")

ctor
{
	addFunction("sendEmail", func(params as DynamicMap) async as dynamic {
		if !params:
			Error.throw("invalidParams", null)
		var mailContent = new SympathyMailContent()
		mailContent.fromDynamicMap(params)
		var message = params.getDynamicMap("message")
		await sendEmail(mailContent, message)
		return null
	})
	addFunction("sendSMS", func(params as DynamicMap) async as dynamic {
		if !params:
			Error.throw("invalidParams", null)
		var number = params.getString("number")
		var message = params.get("message")
		await sendSMS(number, message)
		return null
	})
	addFunction("sendMessage", func(params as DynamicMap) async as dynamic {
		if !params:
			Error.throw("invalidParams", null)
		var recipient = params.getString("recipient")
		var message = params.getDynamicMap("message")
		await sendMessage(recipient, message)
		return null
	})
	addFunction("sendNotification", func(params as DynamicMap) async as dynamic {
		if !params:
			Error.throw("invalidParams", null)
		var recipients = params.getVector("recipients")
		var notificationData = params.getDynamicMap("notificationData")
		await sendNotification(recipients, notificationData)
		return null
	})
}

func isInTestMode virtual as bool
{
	if Boolean.asBoolean(ServerConfig.accept("TEST_MODE"), false) == true:
		return true
	return false
}

func createMailProvider virtual as SympathyMailProvider
{
	var sendGridAPIKey = ServerConfig.accept("SENDGRID_API_KEY")
	if String.isNotEmpty(sendGridAPIKey) {
		var v = new SympathyMailProviderForSendGrid(ctx)
		v.apiKey = sendGridAPIKey
		return v
	}
	var serverAddress = ServerConfig.accept("SMTP_SERVER_ADDRESS")
	if String.isNotEmpty(serverAddress) {
		var type = ServerConfig.require("SMTP_SERVER_TYPE")
		var username = ServerConfig.require("SMTP_USERNAME")
		var password = ServerConfig.require("SMTP_PASSWORD")
		var port = ServerConfig.require("SMTP_PORT")
		var senderAddress = ServerConfig.require("SMTP_SENDER_ADDRESS")
		var senderName = ServerConfig.require("SMTP_SENDER_NAME")
		var v = new SympathyMailProviderForSMTP(ctx)
		v.serverType = type
		v.username = username
		v.password = password
		v.serverAddress = serverAddress
		v.port = port
		v.senderAddress = senderAddress
		v.senderName = senderName
		return v
	}
	return null
}

func createSMSProvider as SympathySMSProvider
{
	var ssid = ServerConfig.accept("TWILIO_SSID")
	if String.isNotEmpty(ssid) {
		var token = ServerConfig.require("TWILIO_AUTH_TOKEN")
		var twilioNumber = ServerConfig.require("TWILIO_PHONE_NUMBER")
		var v = new SympathySMSProviderForTwilio(ctx)
		v.ssid = ssid
		v.token = token
		v.twilioNumber = twilioNumber
		return v
	}
	else {
		return smsApp
	}
	return null
}

func createNotificationProvider as SympathyNotificationProvider
{
	var fcmServerKey = ServerConfig.accept("FCM_SERVER_KEY")
	if String.isNotEmpty(fcmServerKey) {
		var provider = new SympathyNotificationProviderForFirebase(ctx)
		provider.fcmServerKey = fcmServerKey
		return provider
	}
	return null
}

func getExternalTemplate(type as string, templateName as string, language as string) virtual as string
{
	var templateDir = ServerConfig.accept("TEMPLATE_DIRECTORY")
	if not String.endsWith(templateDir, "/"):
		templateDir = templateDir .. "/"
	if String.isNotEmpty(type):
		templateDir = templateDir .. String.toLowerCase(type) .. "/"
	if String.isNotEmpty(language):
		templateDir = templateDir .. String.toLowerCase(language) .. "/"
	var template = File.forPath(templateDir + templateName + ".html.t")
	if not template:
		Log.error(ctx, "Requested template not found: `" .. templateName .. "'")
	return template.getContentsUTF8()
}

func toTemplateNameCompatible(string as string) as string
{
	if not string:
		return ""
	var sb = new StringBuilder()
	var it = String.iterate(string)
	while it {
		var c = it.getNextChar()
		if Character.isEOF(c):
			break
		if c == '-' || c == '_' || c == '.' {
			sb.appendCharacter('_')
		}
		else if Character.isLowercaseAlpha(c) {
			sb.appendCharacter(Character.toUppercase(c))
		}
		else if Character.isDigit(c) {
			sb.appendCharacter(c)
		}
		else if Character.isUppercaseAlpha(c) {
			sb.appendCharacter(c)
		}
	}
	return sb.toString()
}

func getFinalMessageContent(type as string, message as object) virtual as string
{
	assert message
	if message is string:
		return message as! string
	var data = message as DynamicMap
	if not data:
		return null
	var templateName = data.getString("template")
	if String.isEmpty(templateName):
		return null
	var language = data.getString("language")
	if String.isEmpty(language):
		language = defaultLanguage
	var parameters = data.getDynamicMap("parameters")
	if not parameters:
		parameters = new DynamicMap()
	var variableName = "TEMPLATE_" .. toTemplateNameCompatible(templateName) .. "_" .. toTemplateNameCompatible(type)
	if String.isNotEmpty(language):
		variableName = variableName .. "_" .. toTemplateNameCompatible(language)
	var template = EnvironmentVariable.get(variableName)
	if not template:
		template = getExternalTemplate(type, templateName, language)
	if not template {
		Log.error(ctx, "Requested template not found: `" .. variableName .. "'")
		var sb = new StringBuilder()
		sb.appendString(templateName)
		foreach key in parameters.getKeys() {
			sb.appendCharacter(' ')
			sb.appendString(key)
			sb.appendCharacter('=')
			sb.appendString(parameters.getString(key))
		}
		return sb.toString()
	}
	return TextTemplate.processString(template, "<%", "%>", parameters)
}

func guessContentType(content as string) virtual as string
{
	if content && String.getIndexOfString(content, "<html") >= 0:
		return "text/html"
	return "text/plain"
}

func sendMailContent(mailContent as SympathyMailContent) async virtual
{
	if isInTestMode() {
		Log.info(ctx, "Test mode email message: `" .. JSONEncoder.encode(mailContent) .. "'")
		return
	}
	if not mailProvider:
		Error.throw("noMailProvider", null)
	await mailProvider.send(mailContent)
}

func doSendEmail(senderAddress as string, senderName as string, subject as string, recipients as SympathyMailUser[], message as DynamicMap) async
{
	if not recipients:
		Error.throw("missingRecipients", recipients)
	var finalContent = getFinalMessageContent("email", message)
	if not finalContent:
		Error.throw("noContent", message)
	var finalSubject = subject
	if String.startsWith(finalContent, "Subject:") {
		var newline = String.getIndexOfCharacter(finalContent, '\n')
		if newline < 0 {
			finalSubject = String.getEndOfString(finalContent, 8)
			finalContent = ""
		}
		else {
			finalSubject = String.getSubString(finalContent, 8, newline-8)
			finalContent = String.getEndOfString(finalContent, newline+1)
		}
	}
	finalSubject = String.strip(finalSubject)
	finalContent = String.strip(finalContent)
	var contentType = guessContentType(finalContent)
	var mail = new SympathyMailContent()
	var sender = new SympathyMailUser()
	sender.email = senderAddress
	sender.name = senderName
	mail.sender = sender
	foreach recipient in recipients:
		mail.addObjectToVectorField("recipients", recipient)
	mail.subject = finalSubject
	mail.content = finalContent
	mail.contentType = contentType
	await sendMailContent(mail)
}

func sendEmail(mailContent as SympathyMailContent, message as DynamicMap) async
{
	if not mailProvider:
		Error.throw("noMailProvider", null)
	var senderAddress as string
	var senderName as string
	var senderInfo = mailContent.sender
	if senderInfo {
		senderAddress = senderInfo.email
		senderName = senderInfo.name
	}
	if not senderAddress:
		senderAddress = defaultSenderAddress
	if not senderName:
		senderName = defaultSenderName
	await doSendEmail(senderAddress, senderName, mailContent.subject, mailContent.recipients, message)
}

func sendSMSContent(number as string, message as string) async virtual
{
	if isInTestMode() {
		var info = new DynamicMap()
		info.setString("number", number)
		info.setString("content", message)
		Log.info(ctx, "Test mode SMS message: `" .. JSONEncoder.encode(info) .. "'")
		return
	}
	var smp = smsProvider
	if not smp:
		Error.throw("noSMSProvider", null)
	await smsProvider.send(number, message)
}

func sendSMS(number as string, message as object) async
{
	var nn = asPhoneNumber(number)
	if String.isEmpty(nn):
		Error.throw("invalidOrMissingPhoneNumber", number)
	var content = getFinalMessageContent("sms", message)
	if not content:
		Error.throw("noContent", message)
	await sendSMSContent(nn, content)
}

func asPhoneNumber(string as string) as string
{
	assert string
	assert String.contains(string, "@") == false
	var v = new StringBuilder()
	v.appendCharacter('+')
	var it = String.iterate(string)
	while it {
		var c = it.getNextChar()
		if Character.isEOF(c):
			break
		if Character.isDigit(c):
			v.appendCharacter(c)
	}
	return v.toString()
}

func isEmailAddress(string as string) as bool
{
	assert string
	return String.contains(string, "@")
}

func resolveRecipientAddress(recipient as string) virtual as string:
	return recipient

func sendMessage(rcpt as string, message as DynamicMap) async
{
	var recipient = resolveRecipientAddress(rcpt)
	if isEmailAddress(recipient) {
		var mailContent = new SympathyMailContent()
		var recipientInfo = new SympathyMailUser()
		recipientInfo.email = recipient
		mailContent.addObjectToVectorField("recipients", recipientInfo)
		await sendEmail(mailContent, message)
		return
	}
	var number = asPhoneNumber(recipient)
	if number {
		await sendSMS(number, message)
		return
	}
	Error.throw("unsupportedAddress", recipient)
}

func sendNotification(rcpts as object, notificationData as object) async
{
	if not rcpts:
		Error.throw("noRecipients", null)
	if not notificationData:
		Error.throw("noNotificationData", null)
	await notificationProvider.send(rcpts, notificationData)
}

main
{
	return await WebServerMain.execute(args, func(server as WebServer) async {
		server.use(new this())
		if Boolean.asValue(ServerConfig.accept("ENABLE_SMS_WS"), false) {
			smsApp = new SympathySMSProviderForSMSApp(ctx, server)
			Log.debug(ctx, "Enable SMS websocket")
		}
	})
}
