
/*
 * This file is part of Sympathy
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 * Copyright (c) 2018 Eqela Oy
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import jk.sql
import jk.log
import jk.ws.server
import symlib.chat

class is ChatEngine:

prop authenticator as Authenticator
prop eventForwarder as ChatEventForwarderOverHTTP
prop db as SQLDatabase
var userMap private as DynamicMap

ctor:
	userMap = new DynamicMap()

func create(port as int, db as SQLDatabase, authenticator as Authenticator, eventForwarder as ChatEventForwarderOverHTTP, forwarder as NotificationForwarder, ctx as LoggingContext, server as WSServer = null) static as this
{
	var v = new this()
	v.setPort(port)
	v.setDb(db)
	v.setAuthenticator(authenticator)
	v.setEventForwarder(eventForwarder)
	v.setForwarder(forwarder)
	v.setCtx(ctx)
	v.setServer(server)
	return v
}

func createChannelAndGetIdForExternalId(isFromHttpClient as bool, externalId as string, recipients as DynamicVector, creatorUserId as string, title as string, callback as function<void, string>) private
{
	createAndSaveChannelForExternalId(externalId, recipients, creatorUserId, title, func(channel as ChatChannel) {
		assert channel {
			logError("No ChatChannel instance returned by createAndSaveChannelForExternalId() method.")
			callback(null)
		}
		var channelId = channel.getChannelId()
		assert String.isNotEmpty(channelId) {
			logError("Created ChatChannel instance returned by createAndSaveChannelForExternalId() method doesn't have channelId.")
			callback(null)
		}
		logDebug("New channel '" .. channelId .. "' created.")
		assert eventForwarder:
			callback(channelId)
		getUser(creatorUserId, func(user as ChatyUser) {
			assert user:
				callback(null)
			if not isFromHttpClient {
				eventForwarder.onStartGroupChatChannel(creatorUserId, user.getSessionId(), channelId, func(err as Error) {
					if err {
						logError(err.toString())
						callback(null)
						return
					}
				})
			}
			else {
				callback(channelId)
			}
		})
	})
}

func initialize override as bool
{
	assert db:
		logError("No database configured.")
	assert authenticator:
		logError("No auth API client configured.")
	assert DataManager.initialize(db, ctx):
		logError("Failed to initialize data manager.")
	return true
}

func getUserIdsAssociatedWithUserId(userId as string, callback as function<void, DynamicVector, Error>):
	DataManager.getUserIdsAssociatedWithUserId(userId, callback)

func authenticateConnection(authData as buffer, callback as function<void, ChatUser>) override
{
	assert authenticator {
		logError("No authenticator configured.")
		callback(null)
	}
	var sessionId = String.forUTF8Buffer(authData)
	assert String.isNotEmpty(sessionId) {
		logError("No sessionId returned by getSessionId() method. Closing the connection instead.")
		callback(null)
	}
	authenticator.authenticate(sessionId, func(data as DynamicMap, e as Error) {
		assert not e {
			logError("Error: '" .. e.toString() .. "'. Authentication failed.")
			callback(null)
		}
		assert data {
			logError("Invalid response from the authentication service.")
			callback(null)
		}
		var userId = data.getString("userId")
		assert String.isNotEmpty(userId) {
			logWarning("No userId returned from the authentication service.")
			callback(null)
		}
		getUser(userId, func(user as ChatyUser) {
			user.setSessionId(sessionId)
			callback(user)
		})
	})
}

func getUser(userId as string, callback as function<void, ChatyUser>)
{
	var user = userMap.get(userId) as ChatyUser
	if not user {
		user = ChatyUser.create(userId)
		userMap.set(userId, user)
	}
	callback(user)
}

func checkRecipientsAndSender(recipients as DynamicVector, creatorUserId as string, callback as function<void, bool>)
{
	assert String.isNotEmpty(creatorUserId) && recipients && recipients.getSize() > 0:
		callback(false)
	var userIds = assert recipients.duplicate() as DynamicVector:
		callback(false)
	userIds.append(creatorUserId)
	getUser(creatorUserId, func(user as ChatyUser) {
		assert user:
			callback(false)
		authenticator.verifyUserIds(user.getSessionId(), userIds, func(users as DynamicVector, error as Error) {
			callback(not error && users && users.getSize() == userIds.getSize())
		})
	})
}

func getChannel(channelId as string, callback as function<void, ChatChannel>) override
{
	DataManager.getChannel(channelId, func(channel as Channel) {
		callback(createChatChannel(channel))
	})
}

func createChatChannel(channel as Channel) private as ChatChannel
{
	assert channel && String.isNotEmpty(channel.getChannelId()) && String.isNotEmpty(channel.getChannelCreatorUserId())
	var cc = new ChatChannel()
	cc.setChannelId(channel.getChannelId())
	cc.setChannelCreatorUserId(channel.getChannelCreatorUserId())
	cc.setTitle(channel.getTitle())
	cc.setExternalId(channel.getExternalId())
	cc.setTimeStampCreated(channel.getTimeStampCreated())
	cc.setTimeStampLastUpdated(channel.getTimeStampLastUpdated())
	return cc
}

func createAndSaveChannel(recipients as DynamicVector, channelCreatorUserId as string, title as string, callback as function<void, ChatChannel>) override
{
	DataManager.insertChannel(channelCreatorUserId, title, func(channel as Channel, error as Error) {
		assert not error:
			callback(null)
		assert channel:
			callback(null)
		var channelId = channel.getChannelId()
		assert String.isNotEmpty(channelId):
			callback(null)
		DataManager.insertRecipients(channelId, channelCreatorUserId, recipients, func(error2 as Error) {
			assert not error2:
				callback(null)
			assert eventForwarder:
				callback(createChatChannel(channel))
			getUser(channelCreatorUserId, func(user as ChatyUser) {
				assert user:
					callback(null)
				recipients.removeValue(channelCreatorUserId)
				if recipients.getSize() == 1 {
					eventForwarder.onStartChatChannel(channelCreatorUserId, user.getSessionId(), channelId, func(err as Error) {
						if err {
							logError(err.toString())
							callback(null)
							return
						}
						callback(createChatChannel(channel))
					})
				}
				else if recipients.getSize() > 1 {
					eventForwarder.onStartGroupChatChannel(channelCreatorUserId, user.getSessionId(), channelId, func(err as Error) {
						if err {
							logError(err.toString())
							callback(null)
							return
						}
						callback(createChatChannel(channel))
					})
				}
			})
		})
	})
}

func saveMessage(message as ChatMessage, channel as ChatChannel, creatorUserId as string, callback as function<void, Error>) override
{
	assert message && channel && String.isNotEmpty(creatorUserId):
		callback(Error.instance("internal_error", "Internal error"))
	DataManager.insertMessage(message, channel.getChannelId(), creatorUserId, func(v as Message, error as Error) {
		assert not error:
			callback(error)
		assert v:
			callback(Error.instance("internal_error", "Internal error"))
		var messageId = v.getMessageId()
		assert String.isNotEmpty(messageId):
			callback(Error.instance("internal_error", "Internal error"))
		DataManager.updateReadStatus(channel.getChannelId(), creatorUserId)
		message.setMessageId(messageId)
		message.setChannelId(channel.getChannelId())
		message.setCreatorUserId(creatorUserId)
		message.setRecipients(getRecipientIdsForChannelId(channel.getChannelId()))
		message.setTimeStampCreated(v.getTimeStampCreated())
		message.setTimeStampLastUpdated(v.getTimeStampLastUpdated())
		var c = new Channel()
		c.setChannelId(channel.getChannelId())
		c.setChannelCreatorUserId(channel.getChannelCreatorUserId())
		c.setTitle(channel.getTitle())
		c.setExternalId(channel.getExternalId())
		c.setTimeStampCreated(channel.getTimeStampCreated())
		c.setTimeStampLastUpdated(channel.getTimeStampLastUpdated())
		DataManager.updateChannel(c, func(nc as Channel, error2 as Error) {
			assert not error2:
				callback(error2)
			assert nc:
				callback(Error.instance("internal_error", "Internal error"))
			channel.setChannelId(nc.getChannelId())
			channel.setChannelCreatorUserId(nc.getChannelCreatorUserId())
			channel.setTitle(nc.getTitle())
			channel.setExternalId(nc.getExternalId())
			channel.setTimeStampCreated(nc.getTimeStampCreated())
			channel.setTimeStampLastUpdated(nc.getTimeStampLastUpdated())
			callback(null)
		})
	})
}

func getRecipientIdsForChannelId(channelId as string) override as DynamicVector:
	return DataManager.getRecipientIdsForChannelId(channelId)

func getReadStatusAsMapForUserId(userId as string) override as DynamicMap:
	return DataManager.getReadStatusAsMapForUserId(userId)

func getReadStatusAsMapForChannelId(channelId as string) override as DynamicMap:
	return DataManager.getReadStatusAsMapForChannelId(channelId)

func onProcessNewCommandMessage(command as string, creator as ChatUser, message as ChatMessage, callback as function<void, ChatMessage, Error>) override
{
	var user = assert creator as ChatyUser
	var creatorUserId = user.getUserId()
	assert String.isNotEmpty(creatorUserId)
	assert message && message.getMessageType() == ChatMessage.COMMAND_TYPE
	var commandMap = assert JSONParser.parse(message.getData()) as DynamicMap
	var command = commandMap.getString("command")
	if "get_channels" == command {
		var page = commandMap.getInteger("page", 1)
		var externalIdPattern = commandMap.getString("externalIdPattern")
		DataManager.getChannels(creatorUserId, externalIdPattern, page, commandMap.getInteger("limit"), func(channels as DynamicVector, pageCount as int, totalRecords as int) {
			var rsm = getReadStatusAsMapForUserId(creatorUserId)
			foreach channel in channels.toVectorOfDynamicMaps() {
				var channelId = channel.getString("channelId")
				assert String.isNotEmpty(channelId)
				var recipients = getRecipientIdsForChannelId(channelId)
				channel.set("recipients", recipients)
				channel.set("message", DataManager.getRecentMessage(channelId))
				if rsm:
					channel.set("unreadCount", rsm.getLongInteger(channelId))
				if commandMap.getBoolean("includeRecipientsData") {
					eventForwarder.getChatChannelRecipientsData(user.getSessionId(), recipients, func(data as DynamicVector, err as Error) {
						assert not err:
							logError("Error: '" .. err.toString() .. "'.")
						channel.set("recipientsData", data)
					})
				}
			}
			var data = new DynamicMap()
			data.set("command", "get_channels")
			data.set("channels", channels)
			data.set("currentPage", page)
			data.set("totalPages", pageCount)
			data.set("totalRecords", totalRecords)
			var v = new DynamicMap()
			v.set("messageType", ChatMessage.COMMAND_TYPE)
			v.set("data", data)
			var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
			callback(reply, null)
		})
	}
	else if "get_messages" == command {
		var channelId = commandMap.getString("channelId")
		var externalId = commandMap.getString("externalId")
		var page = commandMap.getInteger("page", 1)
		var limit = commandMap.getInteger("limit")
		if String.isNotEmpty(externalId) {
			authenticator.verifyExternalId(user.getSessionId(), externalId, func(responseData as DynamicMap, error as Error) {
				assert not error {
					logError("Verify external id error: '" .. error.toString() .. "'. Closing the connection instead.")
					callback(null, error)
				}
				assert responseData {
					logError("Invalid external id. Closing the connection instead.")
					callback(null, Error.forCode("invalidExternalId"))
				}
				var users = responseData.getDynamicVector("users")
				assert users && users.getSize() > 0 {
					logError("Invalid external id. Closing the connection instead.")
					callback(null, Error.forCode("noUsers"))
				}
				var newRecipients = new DynamicVector()
				var isExternalMember = false
				foreach user in users.toVectorOfDynamicMaps() {
					var userId = user.getString("userId")
					assert String.isNotEmpty(userId) {
						logError("Empty user id found in the list of user ids returned by the authentication server. Closing the connection instead.")
						callback(null, Error.forCode("noUserId"))
					}
					if String.equals(userId, creatorUserId):
						isExternalMember = true
					newRecipients.append(userId)
				}
				assert isExternalMember {
					logError("Current user is not part of the list of user ids returned by the authentication server. Closing the connection instead.")
					callback(null, Error.forCode("currentUserNotExternalMember"))
				}
				var title = responseData.getString("title")
				DataManager.getChannelForExternalId(externalId, func(channel as Channel) {
					if channel && String.isNotEmpty(channel.getChannelId()) {
						channelId = channel.getChannelId()
						if String.isNotEmpty(title) && not String.equals(channel.getTitle(), title) {
							channel.setTitle(title)
							DataManager.updateChannel(channel, func(updatedChannel as Channel, error2 as Error) {
								assert not error2 {
									logError("Update channel error: '" .. error2.toString() .. "'. Closing the connection instead.")
									callback(null, error2)
								}
								assert updatedChannel && String.equals(updatedChannel.getChannelId(), channelId) {
									logError("Update channel internal error. Closing the connection instead.")
									callback(null, Error.forCode("internalError"))
								}
								DataManager.updateRecipients(channelId, creatorUserId, newRecipients, func(error3 as Error) {
									assert not error3 {
										logError("Update recipients error: '" .. error3.toString() .. "'. Closing the connection instead.")
										callback(null, error3)
									}
									DataManager.getMessages(channelId, page, limit, func(messages as DynamicVector, pageCount as int, totalRecords as int) {
										DataManager.updateReadStatus(channelId, creatorUserId)
										var data = new DynamicMap()
										data.set("command", "get_messages")
										data.set("channelCreatorUserId", updatedChannel.getChannelCreatorUserId())
										data.set("title", updatedChannel.getTitle())
										data.set("channelId", channelId)
										data.set("recipients", getRecipientIdsForChannelId(channelId))
										data.set("externalId", externalId)
										data.set("messages", messages)
										data.set("currentPage", page)
										data.set("totalPages", pageCount)
										data.set("totalRecords", totalRecords)
										var v = new DynamicMap()
										v.set("messageType", ChatMessage.COMMAND_TYPE)
										v.set("data", data)
										var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
										callback(reply, null)
									})
								})
							})
							return
						}
						DataManager.updateRecipients(channelId, creatorUserId, newRecipients, func(error2 as Error) {
							assert not error2 {
								logError("Update recipients error: '" .. error2.toString() .. "'. Closing the connection instead.")
								callback(null, error2)
							}
							DataManager.getMessages(channelId, page, limit, func(messages as DynamicVector, pageCount as int, totalRecords as int) {
								DataManager.updateReadStatus(channelId, creatorUserId)
								var data = new DynamicMap()
								data.set("command", "get_messages")
								data.set("channelCreatorUserId", channel.getChannelCreatorUserId())
								data.set("title", channel.getTitle())
								data.set("channelId", channelId)
								data.set("recipients", getRecipientIdsForChannelId(channelId))
								data.set("externalId", externalId)
								data.set("messages", messages)
								data.set("currentPage", page)
								data.set("totalPages", pageCount)
								data.set("totalRecords", totalRecords)
								var v = new DynamicMap()
								v.set("messageType", ChatMessage.COMMAND_TYPE)
								v.set("data", data)
								var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
								callback(reply, null)
							})
						})
						return
					}
					createChannelAndGetIdForExternalId(false, externalId, newRecipients, creatorUserId, title, func(newChannelId as string) {
						getChannel(newChannelId, func(channel as ChatChannel) {
							assert channel && String.equals(channel.getChannelId(), newChannelId) {
								logError("Internal error: fetched channel has different channel id. Closing the connection instead.")
								callback(null, Error.forCode("internalError"))
							}
							DataManager.getMessages(channelId, page, limit, func(messages as DynamicVector, pageCount as int, totalRecords as int) {
								DataManager.updateReadStatus(newChannelId, creatorUserId)
								var data = new DynamicMap()
								data.set("command", "get_messages")
								data.set("channelCreatorUserId", creatorUserId)
								data.set("title", title)
								data.set("channelId", newChannelId)
								data.set("recipients", getRecipientIdsForChannelId(newChannelId))
								data.set("externalId", externalId)
								data.set("messages", messages)
								data.set("currentPage", page)
								data.set("totalPages", pageCount)
								data.set("totalRecords", totalRecords)
								var v = new DynamicMap()
								v.set("messageType", ChatMessage.COMMAND_TYPE)
								v.set("data", data)
								var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
								callback(reply, null)
							})
						})
					})
				})
			})
			return
		}
		if String.isEmpty(channelId) {
			var recipients = commandMap.getDynamicVector("recipients")
			if recipients && recipients.getSize() > 0:
				channelId = DataManager.getChannelIdForRecipients(recipients, creatorUserId)
		}
		assert String.isNotEmpty(channelId)
		DataManager.getChannel(channelId, func(channel as Channel) {
			assert channel && String.equals(channelId, channel.getChannelId())
			DataManager.getMessages(channelId, page, limit, func(messages as DynamicVector, pageCount as int, totalRecords as int) {
				DataManager.updateReadStatus(channelId, creatorUserId)
				var data = new DynamicMap()
				data.set("command", "get_messages")
				data.set("channelCreatorUserId", channel.getChannelCreatorUserId())
				data.set("title", channel.getTitle())
				data.set("externalId", channel.getExternalId())
				data.set("channelId", channelId)
				data.set("recipients", getRecipientIdsForChannelId(channelId))
				data.set("messages", messages)
				data.set("currentPage", page)
				data.set("totalPages", pageCount)
				data.set("totalRecords", totalRecords)
				var v = new DynamicMap()
				v.set("messageType", ChatMessage.COMMAND_TYPE)
				v.set("data", data)
				var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
				callback(reply, null)
			})
		})
	}
	else if "leave_channel" == command {
		var channelId = commandMap.getString("channelId")
		DataManager.getChannel(channelId, func(channel as Channel) {
			assert channel {
				logError("The specified channel id: '" .. channelId .. "' is invalid.")
				callback(null, Error.forCode("invalidChannelId"))
			}
			assert String.isEmpty(channel.getExternalId()) {
				logError("Current user cannot leave specified channel which is part of an external entity.")
				callback(null, Error.forCode("notAllowed"))
			}
			var recipientMap = new DynamicMap()
			var recipients = assert getRecipientIdsForChannelId(channelId)
			foreach r in recipients.toVectorOfStrings():
				recipientMap.set(r, r)
			assert recipientMap.containsKey(creatorUserId) {
				logError("Current user is not part of the specified channel.")
				callback(null, Error.forCode("currentUserNotChannelMember"))
			}
			recipientMap.remove(creatorUserId)
			assert recipientMap.getCount() > 1 {
				logError("Current user cannot leave specified channel.")
			}
			var channelCreatorUserId = channel.getChannelCreatorUserId()
			assert String.isNotEmpty(channelCreatorUserId) {
				logError("Specified channel has no channel creator user id.")
			}
			if not recipientMap.containsKey(channelCreatorUserId) {
				foreach userId in recipientMap.getKeys() {
					if String.isNotEmpty(userId) {
						channelCreatorUserId = userId
						channel.setChannelCreatorUserId(channelCreatorUserId)
						break
					}
				}
				DataManager.updateChannel(channel, func(updatedChannel as Channel, error as Error) {
					assert not error {
						logError("Update channel creator user id error: '" .. error.toString() .. "'.")
						var data = new DynamicMap()
						data.set("command", "leave_channel")
						data.set("channelId", channelId)
						data.set("status", "error")
						data.set("code", error.getCode())
						data.set("message", error.getMessage())
						var v = new DynamicMap()
						v.set("messageType", ChatMessage.COMMAND_TYPE)
						v.set("data", data)
						var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
						callback(reply, null)
					}
					assert updatedChannel {
						logError("Internal error.")
					}
					recipients = DynamicVector.forStringVector(recipientMap.getKeys())
					DataManager.updateRecipients(channelId, null, recipients, func(error as Error) {
						assert not error {
							logError("Update recipients error: '" .. error.toString() .. "'.")
							var data = new DynamicMap()
							data.set("command", "leave_channel")
							data.set("channelId", channelId)
							data.set("status", "error")
							data.set("code", error.getCode())
							data.set("message", error.getMessage())
							var v = new DynamicMap()
							v.set("messageType", ChatMessage.COMMAND_TYPE)
							v.set("data", data)
							var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
							callback(reply, null)
						}
						var data = new DynamicMap()
						data.set("command", "leave_channel")
						data.set("channelId", channelId)
						data.set("status", "ok")
						var v = new DynamicMap()
						v.set("messageType", ChatMessage.COMMAND_TYPE)
						v.set("data", data)
						var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
						callback(reply, null)
					})
				})
				return
			}
			recipients = DynamicVector.forStringVector(recipientMap.getKeys())
			DataManager.updateRecipients(channelId, null, recipients, func(error as Error) {
				assert not error {
					logError("Update recipients error: '" .. error.toString() .. "'.")
					var data = new DynamicMap()
					data.set("command", "leave_channel")
					data.set("channelId", channelId)
					data.set("status", "error")
					data.set("code", error.getCode())
					data.set("message", error.getMessage())
					var v = new DynamicMap()
					v.set("messageType", ChatMessage.COMMAND_TYPE)
					v.set("data", data)
					var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
					callback(reply, null)
				}
				var data = new DynamicMap()
				data.set("command", "leave_channel")
				data.set("channelId", channelId)
				data.set("status", "ok")
				var v = new DynamicMap()
				v.set("messageType", ChatMessage.COMMAND_TYPE)
				v.set("data", data)
				var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
				callback(reply, null)
			})
		})
	}
	else if "delete_channel" == command {
		var channelId = commandMap.getString("channelId")
		DataManager.getChannel(channelId, func(channel as Channel) {
			assert channel {
				logError("The specified channel id: '" .. channelId .. "' is invalid.")
				callback(null, Error.forCode("invalidChannelId"))
			}
			assert String.isEmpty(channel.getExternalId()) {
				logError("Current user cannot leave specified channel which is part of an external entity.")
				callback(null, Error.forCode("notAllowed"))
			}
			var oldRecipientMap = new DynamicMap()
			var oldRecipients = assert getRecipientIdsForChannelId(channelId)
			foreach or in oldRecipients.toVectorOfStrings():
				oldRecipientMap.set(or, or)
			oldRecipientMap.remove(creatorUserId)
			DataManager.deleteChannel(channelId, creatorUserId, func(error as Error) {
				assert not error {
					logError("Update recipients error: '" .. error.toString() .. "'.")
					var data = new DynamicMap()
					data.set("command", "delete_channel")
					data.set("channelId", channelId)
					data.set("status", "error")
					data.set("code", error.getCode())
					data.set("message", error.getMessage())
					var v = new DynamicMap()
					v.set("messageType", ChatMessage.COMMAND_TYPE)
					v.set("data", data)
					var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
					callback(reply, null)
				}
				var data = new DynamicMap()
				data.set("command", "delete_channel")
				data.set("channelId", channelId)
				data.set("status", "ok")
				var v = new DynamicMap()
				v.set("messageType", ChatMessage.COMMAND_TYPE)
				v.set("data", data)
				var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
				callback(reply, null)
				assert oldRecipientMap.getCount() > 0
				data = new DynamicMap()
				data.set("command", "delete_channel")
				data.set("channelId", channelId)
				data.set("status", "warning")
				data.set("recipients", DynamicVector.forStringVector(oldRecipientMap.getKeys()))
				v = new DynamicMap()
				v.set("messageType", ChatMessage.COMMAND_TYPE)
				v.set("data", data)
				var warning = assert createMessage(String.toUTF8Buffer(json.execute(v)))
				broadcastMessage(warning)
			})
		})
	}
	else if "update_recipients" == command {
		var channelId = commandMap.getString("channelId")
		DataManager.getChannel(channelId, func(channel as Channel) {
			assert channel {
				logError("The specified channel id: '" .. channelId .. "' is invalid.")
			}
			assert String.isEmpty(channel.getExternalId()) {
				logError("Current user cannot leave specified channel which is part of an external entity.")
			}
			var newRecipients = commandMap.getDynamicVector("recipients")
			assert newRecipients && newRecipients.getSize() > 0 {
				logError("No recipients specified.")
			}
			var oldRecipientMap = new DynamicMap()
			var oldRecipients = assert getRecipientIdsForChannelId(channelId)
			foreach or in oldRecipients.toVectorOfStrings():
				oldRecipientMap.set(or, or)
			assert oldRecipientMap.containsKey(creatorUserId) {
				logError("Current user is not part of the specified channel.")
			}
			var newRecipientMap = new DynamicMap()
			foreach nr in newRecipients.toVectorOfStrings():
				newRecipientMap.set(nr, nr)
			foreach userId in newRecipientMap.getKeys():
				oldRecipientMap.remove(userId)
			assert newRecipientMap.getCount() > 2 {
				logError("Channel cannot have less than three users.")
			}
			assert newRecipientMap.containsKey(creatorUserId) {
				logError("Current user is not part anymore of the new recipients of the specified channel.")
			}
			var channelCreatorUserId = channel.getChannelCreatorUserId()
			assert String.isNotEmpty(channelCreatorUserId) {
				logError("Specified channel has no channel creator user id.")
			}
			if not newRecipientMap.containsKey(channelCreatorUserId) {
				foreach userId in newRecipientMap.getKeys() {
					if String.isNotEmpty(userId) {
						channelCreatorUserId = userId
						channel.setChannelCreatorUserId(channelCreatorUserId)
						break
					}
				}
				newRecipients = DynamicVector.forStringVector(newRecipientMap.getKeys())
				DataManager.updateRecipients(channelId, creatorUserId, newRecipients, func(error as Error) {
					assert not error {
						logError("Update recipients error: '" .. error.toString() .. "'.")
						var data = new DynamicMap()
						data.set("command", "update_recipients")
						data.set("channelId", channelId)
						data.set("status", "error")
						data.set("code", error.getCode())
						data.set("message", error.getMessage())
						var v = new DynamicMap()
						v.set("messageType", ChatMessage.COMMAND_TYPE)
						v.set("data", data)
						var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
						callback(reply, null)
					}
					var data = new DynamicMap()
					data.set("command", "update_recipients")
					data.set("channelId", channelId)
					data.set("status", "ok")
					var v = new DynamicMap()
					v.set("messageType", ChatMessage.COMMAND_TYPE)
					v.set("data", data)
					var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
					callback(reply, null)
					assert oldRecipientMap.getCount() > 0
					data = new DynamicMap()
					data.set("command", "update_recipients")
					data.set("channelId", channelId)
					data.set("status", "warning")
					data.set("recipients", DynamicVector.forStringVector(oldRecipientMap.getKeys()))
					v = new DynamicMap()
					v.set("messageType", ChatMessage.COMMAND_TYPE)
					v.set("data", data)
					var warning = assert createMessage(String.toUTF8Buffer(json.execute(v)))
					broadcastMessage(warning)
				})
				return
			}
			foreach userId in oldRecipients.toVectorOfStrings():
				newRecipientMap.remove(userId)
			newRecipients = DynamicVector.forStringVector(newRecipientMap.getKeys())
			DataManager.updateRecipients(channelId, creatorUserId, newRecipients, func(error as Error) {
				assert not error {
					logError("Update recipients error: '" .. error.toString() .. "'.")
					var data = new DynamicMap()
					data.set("command", "update_recipients")
					data.set("channelId", channelId)
					data.set("status", "error")
					data.set("code", error.getCode())
					data.set("message", error.getMessage())
					var v = new DynamicMap()
					v.set("messageType", ChatMessage.COMMAND_TYPE)
					v.set("data", data)
					var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
					callback(reply, null)
				}
				var data = new DynamicMap()
				data.set("command", "update_recipients")
				data.set("channelId", channelId)
				data.set("status", "ok")
				var v = new DynamicMap()
				v.set("messageType", ChatMessage.COMMAND_TYPE)
				v.set("data", data)
				var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
				callback(reply, null)
				assert oldRecipientMap.getCount() > 0
				data = new DynamicMap()
				data.set("command", "update_recipients")
				data.set("channelId", channelId)
				data.set("status", "warning")
				data.set("recipients", DynamicVector.forStringVector(oldRecipientMap.getKeys()))
				v = new DynamicMap()
				v.set("messageType", ChatMessage.COMMAND_TYPE)
				v.set("data", data)
				var warning = assert createMessage(String.toUTF8Buffer(json.execute(v)))
				broadcastMessage(warning)
			})
		})
	}
	else if "delete_messages" == command {
		var channelId = commandMap.getString("channelId")
		DataManager.getChannel(channelId, func(channel as Channel) {
			assert channel {
				logError("The specified channel id: '" .. channelId .. "' is invalid.")
			}
			var messageIds = commandMap.getDynamicVector("messages")
			DataManager.deleteMessages(channelId, creatorUserId, messageIds, func(error as Error) {
				assert not error {
					logError("Update recipients error: '" .. error.toString() .. "'.")
					var data = new DynamicMap()
					data.set("command", "delete_messages")
					data.set("channelId", channelId)
					data.set("status", "error")
					data.set("code", error.getCode())
					data.set("message", error.getMessage())
					var v = new DynamicMap()
					v.set("messageType", ChatMessage.COMMAND_TYPE)
					v.set("data", data)
					var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
					callback(reply, null)
				}
				var data = new DynamicMap()
				data.set("command", "delete_messages")
				data.set("channelId", channelId)
				data.set("status", "ok")
				var v = new DynamicMap()
				v.set("messageType", ChatMessage.COMMAND_TYPE)
				v.set("data", data)
				var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
				callback(reply, null)
			})
		})
	}
	else if "create_channel" == command {
		var title = commandMap.getString("title")
		var recipients = commandMap.getDynamicVector("recipients")
		assert recipients && recipients.getSize() > 0 {
			logError("No recipients. Closing the connection instead.")
			callback(null, Error.forCode("noRecipients"))
		}
		var channelId = DataManager.getChannelIdForRecipients(recipients, creatorUserId)
		if String.isEmpty(channelId) {
			createChannelAndGetId(recipients, creatorUserId, title, func(newChannelId as string) {
				getChannel(newChannelId, func(channel as ChatChannel) {
					assert channel && String.equals(channel.getChannelId(), newChannelId) {
						logError("Internal error: fetched channel has different channel id.")
					}
					var data = new DynamicMap()
					data.set("command", "create_channel")
					data.set("channelId", channel.getChannelId())
					data.set("title", channel.getTitle())
					data.set("channelCreatorUserId", channel.getChannelCreatorUserId())
					data.set("recipients", getRecipientIdsForChannelId(channel.getChannelId()))
					data.set("status", "ok")
					var v = new DynamicMap()
					v.set("messageType", ChatMessage.COMMAND_TYPE)
					v.set("data", data)
					var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
					callback(reply, null)
				})
			})
			return
		}
		getChannel(channelId, func(channel as ChatChannel) {
			assert channel && String.equals(channel.getChannelId(), channelId) {
				logError("Internal error: fetched channel has different channel id")
			}
			var data = new DynamicMap()
			data.set("command", "create_channel")
			data.set("channelId", channel.getChannelId())
			data.set("title", channel.getTitle())
			data.set("channelCreatorUserId", channel.getChannelCreatorUserId())
			data.set("recipients", getRecipientIdsForChannelId(channel.getChannelId()))
			data.set("status", "ok")
			var v = new DynamicMap()
			v.set("messageType", ChatMessage.COMMAND_TYPE)
			v.set("data", data)
			var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
			callback(reply, null)
		})
	}
	else if "update_message" == command {
		var nmessage = Message.forDynamicMap(commandMap)
		DataManager.getMessageById(nmessage.getMessageId(), func(message as Message, error as Error) {
			assert not error:
				callback(null, error)
			assert message:
				callback(null, Error.forCode("invalidMessageId"))
			assert String.equals(message.getCreatorUserId(), creatorUserId):
				callback(null, Error.instance("not_allowed", "Not allowed"))
			nmessage.setChannelId(message.getChannelId())
			nmessage.setCreatorUserId(message.getCreatorUserId())
			nmessage.setTimeStampCreated(message.getTimeStampCreated())
			DataManager.updateMessage(nmessage, func(msg as Message, err as Error) {
				assert not err:
					callback(null, err)
				var data = new DynamicMap()
				data.set("command", "update_message")
				data.set("message", msg.toDynamicMap())
				var v = new DynamicMap()
				v.set("messageType", ChatMessage.COMMAND_TYPE)
				v.set("data", data)
				var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
				callback(reply, null)
			})
		})
	}
	else if "delete_message" == command {
		var messageId = commandMap.getString("messageId")
		DataManager.deleteMessage(messageId, creatorUserId, func(error as Error) {
			assert not error {
				logError("Delete message error: '" .. error.toString() .. "'.")
				var data = new DynamicMap()
				data.set("command", "delete_message")
				data.set("messageId", messageId)
				data.set("status", "error")
				data.set("code", error.getCode())
				data.set("message", error.getMessage())
				var v = new DynamicMap()
				v.set("messageType", ChatMessage.COMMAND_TYPE)
				v.set("data", data)
				var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
				callback(reply, null)
			}
			var data = new DynamicMap()
			data.set("command", "delete_message")
			data.set("messageId", messageId)
			data.set("status", "ok")
			var v = new DynamicMap()
			v.set("messageType", ChatMessage.COMMAND_TYPE)
			v.set("data", data)
			var reply = assert createMessage(String.toUTF8Buffer(json.execute(v)))
			callback(reply, null)
		})
	}
	else {
		logError("Unknown command: '" .. command .. "'")
	}
}

func createAndSaveChannelForExternalId(externalId as string, recipients as DynamicVector, creatorUserId as string, title as string, callback as function<void, ChatChannel>)
{
	DataManager.insertChannelForExternalId(externalId, creatorUserId, title, func(channel as Channel, error as Error) {
		assert not error:
			callback(null)
		assert channel:
			callback(null)
		var channelId = channel.getChannelId()
		assert String.isNotEmpty(channelId):
			callback(null)
		DataManager.insertRecipients(channelId, creatorUserId, recipients, func(error2 as Error) {
			assert not error2:
				callback(null)
			callback(createChatChannel(channel))
		})
	})
}

// FOR CHAT API HANDLER

func updateRecipientsForChannelId(channelId as string, recipients as DynamicVector, callback as function<void, Error>)
{
	assert String.isNotEmpty(channelId):
		callback(Error.instance("no_channel_id", "No channel id"))
	DataManager.getChannel(channelId, func(channel as Channel) {
		assert channel:
			callback(Error.instance("invalid_channel_id", "Invalid channel id"))
		assert String.equals(channel.getChannelId(), channelId):
			callback(Error.instance("internal_error", "Internal error"))
		var channelCreatorUserId = channel.getChannelCreatorUserId()
		assert String.isNotEmpty(channelCreatorUserId):
			callback(Error.instance("internal_error", "Internal error"))
		DataManager.updateRecipients(channelId, channelCreatorUserId, recipients, func(error as Error) {
			assert not error:
				callback(error)
			callback(null)
			// FIXME: Broadcast to all recipients for this update.
		})
	})
}

func updateRecipientsForExternalId(externalId as string, recipients as DynamicVector, callback as function<void, Error>)
{
	assert String.isNotEmpty(externalId):
		callback(Error.instance("no_external_id", "No external id"))
	DataManager.getChannelForExternalId(externalId, func(channel as Channel) {
		assert channel:
			callback(Error.instance("invalid_external_id", "Invalid external id"))
		assert String.equals(channel.getExternalId(), externalId):
			callback(Error.instance("internal_error", "Internal error"))
		var channelCreatorUserId = channel.getChannelCreatorUserId()
		assert String.isNotEmpty(channelCreatorUserId):
			callback(Error.instance("internal_error", "Internal error"))
		DataManager.updateRecipients(channel.getChannelId(), channelCreatorUserId, recipients, func(error as Error) {
			assert not error:
				callback(error)
			callback(null)
			// FIXME: Broadcast to all recipients for this update.
		})
	})
}

func createChannelForExternalIdAndGetChannelId(isFromHttpClient as bool, externalId as string, creatorUserId as string, title as string, recipients as DynamicVector, callback as function<void, string, Error>)
{
	assert String.isNotEmpty(externalId):
		callback(null, Error.instance("no_external_id", "No external id"))
	assert recipients && recipients.getSize() > 1:
		callback(null, Error.instance("no_recipients", "No recipients"))
	DataManager.getChannelForExternalId(externalId, func(c as Channel) {
		var newRecipients = new DynamicVector()
		var isExternalMember = false
		foreach recipient in recipients.toVectorOfDynamicMaps() {
			var userId = recipient.getString("userId")
			assert String.isNotEmpty(userId):
				callback(null, Error.instance("no_user_id", "No user id"))
			if String.equals(userId, creatorUserId):
				isExternalMember = true
			newRecipients.append(userId)
		}
		assert isExternalMember:
			callback(null, Error.instance("invalid_creator_user_id", "Invalid creator user id"))
		assert not c:
			callback(null, Error.instance("channel_already_exists", "Channel already exists"))
		createChannelAndGetIdForExternalId(isFromHttpClient, externalId, newRecipients, creatorUserId, title, func(newChannelId as string) {
			assert String.isNotEmpty(newChannelId):
				callback(null, Error.instance("internal_error", "Internal error"))
			callback(newChannelId, null)
		})
	})
}

func deleteChannelForExternalId(externalId as string, callback as function<void, Error>)
{
	assert String.isNotEmpty(externalId):
		callback(Error.instance("no_external_id", "No external id"))
	DataManager.deleteChannelForExternalId(externalId, callback)
}

func onDataMessageFromHTTPControl(data as DynamicMap, callback as function<void, Error>)
{
	var message = createMessage(String.toUTF8Buffer(json.execute(data)))
	assert message && message.getMessageType() == ChatMessage.DATA_TYPE:
		callback(Error.instance("invalid_request", "Invalid request"))
	var creatorUserId = message.getCreatorUserId()
	assert String.isNotEmpty(creatorUserId):
		callback(Error.instance("no_message_creator_user_id", "No message creator user id"))
	var recipients = message.getRecipients()
	assert recipients && recipients.getSize() > 0 {
		logError("Message with no channel id or external id has no recipients.")
		callback(Error.instance("no_recipient", "No recipient"))
	}
	var channelId = DataManager.getChannelIdForRecipients(recipients, creatorUserId)
	if String.isEmpty(channelId) {
		createChannelAndGetId(recipients, creatorUserId, null, func(newChannelId as string) {
			getChannel(newChannelId, func(channel as ChatChannel) {
				assert channel && String.equals(channel.getChannelId(), newChannelId) {
					logError("Internal error: fetched channel has different channel id.")
					callback(Error.instance("internal_error", "Internal error"))
				}
				onSaveMessageFromHTTPControl(message, channel, callback)
			})
		})
		return
	}
	getChannel(channelId, func(channel as ChatChannel) {
		assert channel && String.equals(channel.getChannelId(), channelId) {
			logError("Internal error: fetched channel has different channel id. Closing the connection instead.")
			callback(Error.instance("internal_error", "Internal error"))
		}
		var recipients = getRecipientIdsForChannelId(channelId)
		assert recipients && recipients.getSize() > 1 {
			logError("fetched channel has no recipients.")
			callback(null)
		}
		var recipientMap = new DynamicMap()
		foreach userId in recipients.toVectorOfStrings():
			recipientMap.set(userId, userId)
		assert recipientMap.getCount() > 1 {
			logError("fetched channel has no recipients.")
			callback(null)
		}
		assert recipientMap.containsKey(creatorUserId) {
			logError("Internal error: fetched channel recipients do not include creator user id.")
			callback(Error.instance("internal_error", "Internal error"))
		}
		onSaveMessageFromHTTPControl(message, channel, callback)
	})
}

func broadcastMessageFromHTTPControl(messageId as string, callback as function<void, Error>)
{
	var engine = this
	DataManager.getMessageById(messageId, func(message as Message, error as Error) {
		assert not error:
			logError("Internal error: '" .. error.toString() .. "'")
		var channelId = message.getChannelId()
		getChannel(channelId, func(channel as ChatChannel) {
			channel.setEngine(engine)
			assert channel && String.equals(channel.getChannelId(), channelId) {
				logError("Internal error: fetched channel has different channel id. Closing the connection instead.")
				callback(Error.instance("internal_error", "Internal error"))
			}
			var recipients = getRecipientIdsForChannelId(channelId)
			assert recipients && recipients.getSize() > 1 {
				logError("fetched channel has no recipients.")
				callback(null)
			}
			var recipientMap = new DynamicMap()
			foreach userId in recipients.toVectorOfStrings():
				recipientMap.set(userId, userId)
			assert recipientMap.getCount() > 1 {
				logError("fetched channel has no recipients.")
				callback(null)
			}
			assert recipientMap.containsKey(message.getCreatorUserId()) {
				logError("Internal error: fetched channel recipients do not include creator user id.")
				callback(Error.instance("internal_error", "Internal error"))
			}
			var data = new DynamicMap()
			data.set("messageType", ChatMessage.DATA_TYPE)
			var mdta = message.toDynamicMap()
			mdta.set("recipients", recipients)
			data.set("data", mdta)
			var cmessage = assert createMessageFromMap(data) {
				logError("Failed to create chat message instance.")
				callback(Error.instance("internal_error", "Internal error"))
			}
			callback(null)
			channel.onNewDataMessage(cmessage)
		})
	})
}

func onSaveMessageFromHTTPControl(message as ChatMessage, channel as ChatChannel, callback as function<void, Error>) private
{
	channel.setEngine(this)
	saveMessage(message, channel, message.getCreatorUserId(), func(error as Error) {
		assert not error {
			logError("Internal error: '" .. error.toString() .. "'. Closing the connection instead.")
			callback(Error.instance("internal_error", "Internal error: '" .. error.toString() .. "'"))
		}
		assert String.isNotEmpty(message.getMessageId()) {
			logError("Internal error: Saved message has no message id generated. Closing the connection instead.")
			callback(Error.instance("internal_error", "Internal error"))
		}
		assert String.equals(message.getChannelId(), channel.getChannelId()) {
			logError("Internal error: Saved message has different channel id. Closing the connection instead.")
			callback(Error.instance("internal_error", "Internal error"))
		}
		callback(null)
		channel.onNewDataMessage(message)
	})
}
